package ml.perceptron;import java.util.ArrayList;import java.util.Arrays;import java.util.Iterator;import java.util.LinkedHashMap;/** * Created with IntelliJ IDEA. * User: st316 * Date: 13-10-30 * Time: 下午2:59 */public class Perceptron {    private TrainingSet ts;    private double[] w;//原始形式使用    private double[] a;//对偶形式使用    private double b;    private double LR;    public Perceptron() {    }    public Perceptron(TrainingSet ts) {        this.ts = ts;        this.w = new double[ts.getPointDim()];        this.a = new double[ts.getCount()];        this.b = 0;        this.LR = 1;    }    public Perceptron(TrainingSet ts, double[] initialW, double initialB) {        this.ts = ts;        this.w = initialW;        this.b = initialB;    }    public Perceptron(TrainingSet ts, double[] initialW, double initialB, double LR) {        this.ts = ts;        this.w = initialW;        this.b = initialB;        this.LR = LR;    }    public void train() {//原始形式的学习算法        LinkedHashMap<Point, Boolean> tsMap = ts.getTs();        boolean flag;        do {//            System.out.println(this);            flag = true;            for (Iterator it = tsMap.keySet().iterator(); it.hasNext(); ) {                Point p = (Point) it.next();                double sum = 0;                for (int i = 0; i < w.length; i++)                    sum += w[i] * p.getValue()[i];//                System.out.println(sum + b);//                System.out.println(tsMap.get(p));                if ((sum + b <= 0 && tsMap.get(p))) {//该点为误分类点                    for (int i = 0; i < w.length; i++)                        w[i] += this.LR * p.getValue()[i];                    b += this.LR;                    flag = false;                    break;                }                if (sum + b > 0 && !tsMap.get(p)) {//该点为误分类点                    for (int i = 0; i < w.length; i++)                        w[i] -= this.LR * p.getValue()[i];                    b -= this.LR;                    flag = false;                    break;                }            }        } while (!flag);    }    public void dualTrain() {//对偶形式的学习算法        LinkedHashMap<Point, Boolean> tsMap = ts.getTs();        ArrayList<Point> ps = new ArrayList<Point>();        for (Iterator it = tsMap.keySet().iterator(); it.hasNext(); )            ps.add((Point) it.next());        int n = tsMap.size();        int[][] gramMatrix = new int[n][n];        for (int i = 0; i < n; i++)            for (int j = 0; j < n; j++)                for (int k = 0; k < ts.getPointDim(); k++)                    gramMatrix[i][j] += ps.get(i).getValue()[k] * ps.get(j).getValue()[k];        boolean flag;        do {            int count = 0;            flag = true;            for (Iterator it = tsMap.keySet().iterator(); it.hasNext(); ) {                Point p = (Point) it.next();                double sum = 0;                int i;                for (i = 0; i < a.length; i++) {                    if (tsMap.get(ps.get(i)))                        sum += a[i] * gramMatrix[i][count];                    else                        sum -= a[i] * gramMatrix[i][count];                }                if (sum + b <= 0 && tsMap.get(p)) {                    a[count] += this.LR;                    b += this.LR;                    flag = false;                    break;                }                if (sum + b > 0 && !tsMap.get(p)) {                    a[count] += this.LR;                    b -= this.LR;                    flag = false;                    break;                }                count++;            }            //System.out.println(Arrays.toString(a) + b);        } while (!flag);        for (int i = 0; i < w.length; i++) {            for (int j = 0; j < a.length; j++)                if (tsMap.get(ps.get(j)))                    w[i] += a[j] * ps.get(j).getValue()[i];                else                    w[i] -= a[j] * ps.get(j).getValue()[i];        }    }    public boolean compute(Point p) {        double sum = 0;        for (int i = 0; i < w.length; i++)            sum += w[i] * p.getValue()[i];        return sum + b > 0;    }    public void setA(double[] a) {        this.a = a;    }    @Override    public String toString() {        return "Perceptron{" +                "w=" + Arrays.toString(w) +                ", b=" + b +                '}';    }}